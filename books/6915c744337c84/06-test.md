---
title: "テストによる設計の質の向上"
---

React Native でもテストを書くことが可能です。目的としては次が挙げられます。

- 要求や仕様を満たしているかのチェック
- 設計改善

## 要求や仕様を満たしていることを確かめるテスト

ソフトウェアのテストと聞くとこの目的を思い浮かべることが多いでしょう。しかし、これを確かめるのは非常に大変です。V モデルという品質担保のモデルでは、ユーザーが抱く課題から要求および仕様へと細部が明確化され、実装へと繋がります。同時に、ユーザーの課題を解決できるかや要求、仕様がそれぞれ想定どおりかを満たすテストが作成されます。

![Vモデル](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Systems_Engineering_Process_II.svg/840px-Systems_Engineering_Process_II.svg.png)

つまり「要求を満たしている」とは要求が明確に定まり、どのような状態であれば要求が満たされているかを記述できるという前提が必要となるのです。5 章で検討したユースケースは要求となりうるでしょう。その他の手法やツールを用いてより詳細に分析をしてもよいでしょう。ただし、アプリの開発後にそれらを満たせているかどうかのチェックを忘れないようにしましょう。

仕様についても同様ですが、こちらは 5 章で述べた各画面の責務や画面遷移などが該当します。こちらも画面実装後、想定通りに作れたかどうかをチェックする必要があります。

要求および仕様のチェックはアプリの提供側（開発者や品質保証に責任を負うメンバー）が実施可能です。ただし開発者が想定するテストケースは一般的に十分なものとならないことに注意してください。時間をおいたり気持ちを切り替えてテストケースを作成したり、別のチームメンバーに頼むとよいでしょう。

より重要なことは「ユーザーの課題を解決できているか」という一点に尽きます。これはアプリ作成前のユーザーリサーチやユーザーからのフィードバックによって実現します。5 章で考えたリーンキャンバスは想定ユーザーにインタビューするための資料となります。この点はソフトウェアテストの範疇外となりますが、非常に重要です。必要とされるアプリを開発しましょう。

### テストの範囲

仕様については、ある程度の部分をソフトウェアテストによって検証できます。「画面がどのような構造となっているか」「ボタンを押した際に駆動するロジックが想定どおりか」などは機械的に記述可能でしょう。これらの書き方は各章で適宜解説します。

要求については E2E テストなどユーザーの操作を模倣するテストであれば一部は自動的に実施可能でしょう。E2E テストについては 11 章で解説します。

また、ドッグフーディングすることもよいチェックとなるでしょう。ドッグフーディングとは開発に携わるメンバーが、作っているプロダクトを普段から使用し、問題や改善点を発見する手法です。モバイルアプリは生活の中で使用しやすいため、比較的取り入れやすい利点があります。

ドッグフーディングは次の特徴を持っています。

- 基本的な機能に不具合がある場合、すぐに気づくことができる
- UI の使いづらい点を発見できる

その他にもチームメンバーがターゲット層と同じ属性を持っている場合、UX の改善点に気づけたり、より本質的な機能改善がしやすくなるでしょう。ユーザーの課題を解決できているかをチェックできる可能性があります。

ただし、ユーザーの課題を解決できているかについては直接ユーザーに判断してもらうのが一番です。

## 設計改善のためのテスト

[テストを作成したほうがよいもうひとつの理由は、設計を改善するための助けとなるから](https://shop.ohmsha.co.jp/shopdetail/000000004967/)です。特にアプリのコアとなるロジックやユーティリティとして使う関数などはテストを書くことによってよりよい設計ができるようになるでしょう。

まずコードを実行し、結果を確かめながら書いていける点は開発者の安心感につながります。さらに、テストを実行すれば想定した挙動についてコードが正しく動くかどうかについては判断できるため、どこまで検証したかなど余計なことを覚えておく必要がありません。いま目の前のコードへ集中できるようになるのです。

粒度やインターフェイスについて気を使うようになることもメリットです。テストから呼び出し可能な単位でコードを分割するようになり、呼び出しやすいインターフェイスを心がけるモチベーションとなります。

また、この目的で書いたテストは仕様通りに動作するかどうかのチェックとなりえます。メリットが多いため、ぜひ開発と同時にテストを書きましょう。

この文脈でのテストにはユニットテストを使用します。

## Jest によるユニットテスト

ユニットテストとは関数やクラス単位がその責務を果たしているかを確かめるためのテストです。主に開発者が作成し、実行可能です。

ユニットテストの作成および実行を支援するためのフレームワークやライブラリーが、数多く開発されています。その中で、React Native では同じく Facebook 製の Jest が推奨されています。React Native と親和性が高く、その他のツールを選択する理由がないことから、本書では Jest を使用してテストを作成します。

:::details コラム: テスト実行用パッケージの選択
本書では Jest を用いますが、テスト実行用のパッケージはどのように選定すればよいでしょうか。

テストは既存のコードが意図通りに動くかどうかを確かめる、という側面も持っています。リファクタリングの際はテストがパスすることを確かめながらコードを変更することで、開発効率の向上が見込め、開発者への負担が軽くなります。このように、テストは開発における拠り所となります。特に最終更新から長く時間が経過したプロジェクトにおいて、テストの有無は大きな関心事でしょう。

また、アプリケーションのコードは様々な要因で変更されます。外部システムや依存パッケージのインターフェイス変更、脆弱性情報の発表などによってコードの修正を迫られます。それに比べ、アプリの仕様や設計が変更されない限りテストコードは変更されません。

その点で、テストコードのライフサイクルはアプリケーションコードより長いのです。これを踏まえて安定的で長くメンテナンスされる可能性の高いパッケージを選定しましょう。

Jest は Facebook が開発していることもありますが、そのシェアが高くなってきていること、多くのコントリビューターが集まっていることから、すぐに開発が止まる可能性は低そうです。
:::

### 最初のテスト実行

Jest はプロジェクトセットアップ時にインストールされています。次のコマンドを実行してください。

```console
yarn test
```

今後このコマンドは何回も叩きますので覚えておきましょう。セットアップ直後の状態では `__test__/App-test.tsx` というファイルに記載されたテストが実行されます。

### テストの書き方

Jest は次の条件のいずれかに合致するファイルをテストとして実行します。

1. `__tests__` ディレクトリー以下に存在する、拡張子が `.js`、`.ts` もしくは `.tsx` のファイル
2. 拡張子が `.test.js`、`.test.ts` もしくは `.test.tsx` のファイル

拡張子 `.ts` は TypeScript で記述されたソースコードです。`.tsx` は JSX が記述された TypeScript のソースコードになります。

本書では 2 番の方式を用い、テストしたいコードとテストコードを同階層に配置します。両者の位置が離れていると次の弊害があるためです。

- テストコードを探すことが難しい
- テストが存在しないことに慣れてしまう

対して同階層にテストを配置することのデメリットはディレクトリー内のファイル数が 2 倍になることですが、適切にディレクトリー整理ができていれば開発に影響を与えません。

### テストを書く

ではかんたんなテストから書いて慣れていきましょう。オブジェクトの値を、そのプロパティの内容すべて含めてコピーするユーティリティ関数 `deepCopy` をテストします。

```typescript:deep-copy.ts
// deep-copy.ts
export default function deepCopy<T>(target: T): T {
  return JSON.parse(JSON.stringify(target));
}
```

`deepCopy` の実装はこんなものでしょう。早速同じ階層にテストを書きましょう。

```typescript:deep-copy.test.ts
// deep-copy.test.ts
import deepCopy from './deep-copy';

const deepObject = {
  foo: 1,
  bar: {
    foo: {
      foo: [0, 1, 2],
      bar: {
        foo: {
          foo: true,
          bar: ['foo', 'bar'],
        }
      },
    },
  },
};

describe('deepCopy', () => {
  test('引数と値が同じオブジェクトを返す', () => {
    expect(deepCopy(deepObject)).toEqual(deepObject);
  });
  test('引数と参照が異なるオブジェクトを返す', () => {
    expect(deepCopy(deepObject)).not.toBe(deepObject);
  });
});
```

`describe` 関数はテストをグルーピングするために用います。第 1 引数は文字列でテスト対象や場合分けを明示します。第 2 引数にテスト群を記述した関数を指定します。`describe` によってグルーピングされたひとつのまとまりを Test Suite（テストスイート）と呼びます。

`test` 関数はテストを定義するために使うものです。第 1 引数は文字列で、そのテストで確かめたいことを簡潔に記述します。第 2 引数にテスト内容を記述した関数を指定します。

`test` 関数と同様の挙動である `it` 関数も提供されています。テスト対象を `describe` に記述し、その中身でテスト対象が満たすべき挙動を `it` 関数で確かめていくという書き方も可能です。

```typescript:deep-copy.test.ts
describe('deepCopy', () => {
  it('returns cloned objects', () => {
    expect(deepCopy(deepObject)).toEqual(deepObject);
  });
});
```

"it returns cloned objects"と、英語として読み下せるのが特徴です。

テスト内容の中で確かめたいことを記述していきますが、このときに `expect` 関数とそれに続くマッチ関数を指定していきます。`expect` 関数の引数には確かめるべき対象を指定します。ここでは `deepCopy` 関数の実行結果です。`toEqual` はオブジェクトのプロパティとその内容まで値が等しいことを確かめるものです。`toBe` 関数は演算子 `===` による比較です。ここでは `not` を指定してマッチしないことを表現しています。

`toEqual` 関数や `toBe` 関数はマッチ関数と呼ばれ、Jest によって提供されている一連の比較関数です。マッチ関数については[公式のドキュメント](https://jestjs.io/docs/en/using-matchers)を参照しながら、適宜必要なものを使ってください。

ここまで書けたら `yarn test` を実行しましょう。すべてのテストが `PASS` 、つまり成功していることが確認できるでしょう。

## テストを書かない対象を見極める

これからの章でテストの書き方を解説しますが、無理にすべてを書く必要はありません。もちろん書ける場所は積極的に書いたほうがよいでしょう。ただしテストの実装工数が賄えない場合やすべてについてテストを書かなければならないという義務感を軽減するため、優先度付けして書きやすくする工夫は必要です。

上述したテストは設計を良くするための補助として用いる用途が主であるため、本質的に複雑な領域に対してはしっかり書くことが目的にかなうでしょう。この観点では、機能が壊れてはならないアプリのコアロジックと、複雑になりがちな部分のテストを厚めに書くことが望ましいと言えます。

React など、枠組みが確立しており設計の自由度が少ない領域については必要最低限に絞ってよいでしょう。具体的にコンポーネントや後述する Redux 関係のテストについては省略しても影響は少ないでしょう。複雑になるに従って整備していく、という戦略を取ることを視野に入れ現実的な選択をしましょう。

## CI を取り入れ安定した開発をする

CI とは Continuous Integration の略です。できる限り短いサイクルで変更を merge しテスト・ビルドを実施することで既存の機能が壊れていないかを早めに発見し対処することを目的としています。アプリの機能が壊れることを阻止することと、それ以上に問題が大きくなる前に対処することで開発者の心理的負担を軽くし、軽快な開発を可能にすることが利点です。

CI 用のシステムを導入することで利用可能ですが、SaaS として提供されているものが多い分野です。本書では価格や機能が手頃で、チームの大きさや開発速度が変化しても対応可能な CircleCI を用いた例を紹介します。

### CircleCI のセットアップ

CircleCI を使うため、まずアカウント登録してください。GitHub もしくは Bitbucket のアカウントが必要です。

アカウント登録が完了したら早速 CI の設定をしましょう。ログイン後のページで次の操作を実施します。

1. 左端の `ADD PROJECTS` ボタンを押す
2. 対象のリポジトリーの右端にある `Set Up Project` ボタンを押す
3. CircleCI の設定を `.circleci/config.yml` として保存し、master ブランチに push もしくは merge する
4. `Start building` ボタンを押す

CircleCI の設定は次です。`/.circleci/config.yml` に記載してください。

```yaml
---
# /.circleci/config.yml
# refer: https://circleci.com/docs/2.1/language-javascript/
version: 2.1

executors:
  node-lts:
    docker:
      - image: circleci/node:12.14
    working_directory: ~/repo

commands:
  setup:
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "package.json" }}
            - v1-dependencies-

jobs:
  build:
    executor: node-lts
    steps:
      - setup
      - run: yarn
      - save_cache:
          paths:
            - node_modules
          key: v1-dependencies-{{ checksum "package.json" }}
  test:
    executor: node-lts
    steps:
      - setup
      - run:
          command: |
            yarn type-check
            yarn lint
            yarn coverage
      - store_artifacts:
          path: ~/repo/coverage

workflows:
  version: 2
  test:
    jobs:
      - build
      - test:
          requires:
            - build
```

`build` と `test` というふたつのジョブを設定しています。それぞれ必要なパッケージのインストールおよび各種のチェックをするためのジョブです。このふたつのジョブを組み合わせて `test` というワークフローを定義しています。`test` ジョブの実行のために `build` ジョブが必要という条件をつけていますので、このワークフローは常に `build` ジョブが先に実行されます。

`build` と `test` のジョブをひとつにまとめてしまってもよいのですが、今後デプロイやその他のタスクを実行したい場合に `build` ジョブが独立していると定義しやすいため、わけています。

同時に CircleCI のジョブの中で使っているコマンドも定義しましょう。`package.json` の `scripts` プロパティに次の 3 行を追加してください。

```json:package.json
    "type-check": "tsc --noEmit",
    "lint": "eslint index.js $(find src -name '*.ts' -a -not -name '*.d.ts' -o -name '*.tsx')",
    "coverage": "jest --coverage",
```

`type-check` は型チェックのための npm スクリプトです。TypeScript による型チェックのみ実行します。`lint` は ESLint による静的解析です。`coverage` は Jest によるテストを実行しますが、同時にテストカバレッジを出力します。出力先は `coverage` ディレクトリーです。手元で実行したときにファイル管理の邪魔になりますので、Git で無視するよう設定しましょう。`.gitignore` の最後に次を追加してください。

```conf:.gitignore
coverage
```

設定が完了すると、すべてのブランチにおいて自動的にテストが実行されるようになります。変更対象以外のテストが失敗していることを検出できるようになりますので、問題が起こっても軽微なうちに対処可能となります。
